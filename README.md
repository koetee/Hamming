# Hamming

Этот проект был сделан для того, чтобы продемонстрировать, как код Хамминга может быть реализован в C# для кодирования данных и обнаружения ошибок. Код берет входную строку битов данных, добавляет биты четности, чтобы убедиться, что у каждой группы битов есть четное число 1, и вычисляет значения битов четности на основе битов данных, которые они покрывают. Полученные в результате закодированные данные можно отправить по шумному каналу, а код Хамминга можно использовать в конце приема для обнаружения и исправления ошибок.

## Алгоритм

Скажем, пользователь вводит входные данные "1010". 

Во-первых, код вычисляет необходимое число бит четности. В этом случае существует 4 бита данных, поэтому нам нужно добавить 3 бита четности, чтобы каждая группа битов была четной. Мы можем вычислить число бит четности, необходимое для следующего кода:
```css
int numParityBits = 0;
while (Math.Pow(2, numParityBits) < data.Length + numParityBits + 1)
{
    numParityBits++;
}
```
В этом случае код задает значение 'numParityBits' равное 3.

Затем код создает массив для хранения закодированных данных с достаточным пространством для битов данных и битов четности:

```css
int[] encodedData = new int[data.Length + numParityBits];
```

В этом случае массив 'encodedData' содержит 7 элементов.

Затем код вставляет биты данных в закодированный массив данных. Для каждого элемента массива, если он соответствует мощности 2 (т.е. бит четности), код устанавливает значение 0 на данный момент. В противном случае код копирует соответствующий бит из входных данных:

```css
int dataIndex = 0;
for (int i = 0; i < encodedData.Length; i++)
{
    if (IsPowerOfTwo(i + 1))
    {
        encodedData[i] = 0;
    }
    else
    {
        encodedData[i] = int.Parse(data[dataIndex].ToString());
        dataIndex++;
    }
}
```
В этом случае закодированный массив данных выглядит:
| 0 | 1 | 0  | 1 | 0 | 0 |  0 | 
| -- | -- | -- | -- | -- | -- |-- |

Далее код вычисляет биты четности. Для каждого бита четности код сначала вычисляет индекс бита (например, бит четности 1 имеет индекс 0, бит четности 2 имеет индекс 1 и т.д.). Затем он вычисляет четность каждой группы битов, которая включает этот бит четности. Чтобы сделать это, он выполняет итерацию по каждой группе битов, которая включает бит четности, и преобразует их в XOR вместе. В итоге он устанавливает бит четности на вычисленную четность:

```css
for (int i = 0; i < numParityBits; i++)
{
    int parityBitIndex = (int)Math.Pow(2, i) - 1;
    int parity = 0;
    for (int j = parityBitIndex; j < encodedData.Length; j += (parityBitIndex + 1) * 2)
    {
        for (int k = 0; k < parityBitIndex + 1 && j + k < encodedData.Length; k++)
        {
            parity ^= encodedData[j + k];
        }
    }
    encodedData[parityBitIndex] = parity;
}
```
В нашем примере биты четности вычисляются следующим образом:

    Бит четности 1: XOR битов 1, 3, 5, 7 = 1

    Бит четности 2: XOR битов 2, 3, 6, 7 = 0

    Бит четности 3: XOR битов 4, 5, 6, 7 = 1
Итак, закодированный массив данных теперь выглядит следующим образом:

| 1 | 0 | 1  | 1 | 0 | 1 |  0 | 
| -- | -- | -- | -- | -- | -- |-- |


## Источники

 - [Википедия](https://ru.wikipedia.org/wiki/Код_Хэмминга)
 - [Статья на Хабр](https://habr.com/ru/post/140611/)


